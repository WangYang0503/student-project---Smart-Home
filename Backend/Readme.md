# Backend
## Übersicht
Um das Smart-Home nun tatsächlich auch “smart” machen zu können, sodass es in bestimmten Situationen von alleine vordefinierte Aktionen auslöst, genügt die direkte Kommunikation der Smart-Things über die Middleware nicht. In diesem Fall müssten Verknüpfungen zur Kommunikation der Smart-Things untereinander umständlich direkt in dem Quellcode der einzelnen Komponenten implementiert werden und wären folglich ohne Neukompilierung des jeweiligen Projekts nicht durch den Endanwender anpassbar. Wenn der Benutzer beispielsweise wollen würde, dass ihm ein Kaffee gekocht wird, wenn er mit seinem Smart Car in der Garage angekommen ist, so hätte vorher direkt im Quellcode implementiert worden müssen, dass das Auto - wenn es erkennt, dass es in der Garage angekommen ist - ein Event zum Kaffeekochen an die Kaffeemaschine sendet, dass diesen Vorgang startet. Da dies natürlich eine sehr unkomfortable Art der Konfiguration des Smart Homes darstellt, übernimmt das Backend diese Aufgabe, in welchem der Benutzer über eine Weboberfläche die Regeln, die für sein Smart Home greifen sollen, einstellen und verwalten kann. Bei diesen Regeln handelt es sich dabei um “Wenn-Dann-Regeln”: Eine Aktion wird vom Smart-Home dann ausgelöst oder ausgeführt, wenn zuvor ein bestimmtes Ereignis oder eine bestimmte Situation aufgetreten ist.

## Aufbau
### Hauptprogramm
Als Grundgerüst des Backends fungiert ein Java-Programm, welches selbst auch ein KAA-SDK besitzt und darüber Zugriff auf die Schnittstellen aller Smart-Things erhält. Es ist somit über entsprechende Listener in der Lage, auf die ausgesendeten Events aller Smart-Things zu reagieren, wie beispielse “Auto ist in Garage angekommen”, und selbst Events an diese Smart-Things auszusenden, die dann dementsprechend Aktionen, wie beispielsweise Kaffeekochen, auslösen können.

### Regeldatenbank
Ausgehend von dieser Basis besitzt das Backend eine [SQLite-Datenbank](database.sqlite "Verweis auf die SQLite-Datenbankdatei"), in der Regeln - bestehend aus einem Regelnamen, dem Eventnamen des Trigger-Events (“Wenn”-Teil der Regel), dem Namen der auszuführenden Aktionsmethode (“Dann”-Teil der Regel) und dem Status der Regel (Aktiv oder Inaktiv) - gespeichert werden können. Diese Datenbank ist über Data Access Objects (DAOs) direkt in den Java-Server eingebunden, sodass dort mittels “Rule”-Objekte im objektorientierten Sinne mit der Datenbank gearbeitet werden kann. Eine sogenannte “RuleWorker”-Klasse übernimmt auf dem Server die Aufgabe, auf Eingabe eines Eventnamens aus dieser Datenbank alle passenden Regeln herauszusuchen, die diesen Eventnamen als Trigger-Event gespeichert haben, die dazugehörige Aktionsmethode abzufragen und schlussendlich über Java-Reflection auszulösen. Bei den Aktionsmethoden handelt es sich nicht direkt um Events, die sofort vom Backend ausgesendet werden sollen, sondern um die Namen von Java-Methoden innerhalb einer “Implementation”-Klasse, die alle möglichen Aktionen definieren, die vom Backend aus ausgelöst werden können. Dies erlaubt viel komplexere Aktionen, denn so können mit einer einzigen Regel eine Vielzahl von Events ausgesendet werden, wie beispielsweise das Ändern der Lichtfarbe auf rot, das Einschalten des Lichts und das Kochen von Kaffee - ausgelöst durch nur eine Regel.

### Webbenutzeroberfläche
Das Backend besteht weiter aus einer Webserver-Komponente, die sowohl statische Webseiten ausgeben, als auch Ajax-Requests entgegennehmen, verarbeiten und beantworten kann. Eine entsprechende Weboberfläche, die neben HTML, CSS und JavaScript auch Twitters Bootstrap-Framework verwendet, bietet die Möglichkeit, über ein Formular neue Regeln anzulegen, diese in einer Tabelle anzuzeigen, zu editieren, zu löschen, zu aktivieren, zu deaktivieren und sie auch direkt über die Weboberfläche auszuführen, ohne dass das zugehörige Triggerevent dafür ausgelöst werden muss, beispielsweise zu Testzwecken. Ferner steht neben einem persistenten Log, das alle Aktionen des Smart-Homes, sowie alle eingehenden und ausgehenden Events und die jeweils ausgelösten Regeln aufzeichnet, auch ein sogenanntes “Live Log” zu Verfügung, das dem Benutzer in Echtzeit auf der Weboberfläche zeigt, welche Events wann eingegangen sind, welche Regeln dafür gefunden werden konnten, welche Aktionen daraufhin ausgelöst und welche Events versendet worden sind. Auch gibt es auf der Weboberfläche eine Funktion, um die beiden Microcontroller (Raspberry Pi und Banana Pi), auf denen alle benötigten Server des Smart Homes ausgeführt werden und auch das Wlan-Netzwerk aufgespannt wird, aus der Ferne herunterzufahren oder bei Bedarf neuzustarten. Die gesamte Kommunikation der Weboberfläche mit dem Backend-Server findet dabei über Ajax-Requests in JavaScript statt. Im Falle des “Live Logs” kommt dabei “Long Polling” als Technik zum Einsatz: Dadurch sendet der Client (in dem Fall der Browser) in regelmäßigen Abständen Anfragen an den Server, die von diesem aber nicht sofort beantwortet werden, sondern erst, wenn es ein neues Ereignis gibt, das dem Anwender angezeigt werden soll. Gibt es von Seiten des Servers für längere Zeit kein neues zu übermittelndes Log, so bricht die Anfrage seitens des Clients nach einiger Zeit (etwa einer Minute) mit einem Timeout ab und startet daraufhin sofort die nächste Long-Polling-Anfrage, die ebenfalls wieder mindestens so lange vom Server unbeantwortet bleibt, wie es noch kein neues Log gibt, das angezeigt werden soll. Dadurch kann auf der Weboberfläche in Echtzeit angezeigt werden, was gerade auf dem Backend-Server geschieht, ohne dass ein ständiges Neuladen der Seite oder das Versenden vieler Server-Anfragen in kurzen zeitlichen Abständen notwendig wäre.

## Zusammenfassung
Das Backend bietet dem Benutzer des Smart Homes über eine Weboberfläche eine sehr komfortable Möglichkeit, “Wenn-Dann-Regeln” für das Smart-Home nach eigenen Wünschen individuell zu verwalten, die die Art und Weise festlegen, auf der die einzelnen innerhalb dieses Projekts entwickelten Smart-Things miteinander interagieren können.